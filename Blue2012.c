#define _CRT_SECURE_NO_WARNINGS 1
#include<stdio.h>
#include<math.h>
//https://blog.csdn.net/kiwi_berrys/article/details/111187699
//第一题
//假设有两种微生物X和Y，X出生后每隔3分钟分裂一次（数目加倍），Y出生后每隔2分钟分裂一次（数目加倍）。
//一个新出生的X，半分钟之后吃掉1个Y，且从此开始每隔1分钟吃掉1个Y。已知新出生的X = 10，Y = 89，求60分钟后Y的数目。
//若X = 10，Y = 90呢？
//本题的要求就是写出这两种初始条件下，60分钟后Y的数目。
//题目的结果令你震惊吗？这不是简单的数字游戏！真实的生物圈有着同样脆弱的性质！
//也许因为你消灭的那只Y就是最终导致Y种群灭绝的最后一根稻草！

// i= 0,x = 10,y = 89| i = 1， x = 10, y = y-x| i=2， x = 10 ,y = 79 |
// i=3,x=10,y = 69   | i = 4,x = 10 y = 158| i=5,x = 10,y=158-x=148
// i=6,x=x*2=20 y = 148 | i = 7 ,x = 20,y = 148-x = 128
//由此可见 x的数量不用管 一到时间就翻倍即可 y的数量当i为奇数时就减去一个x(每隔一分钟) 这道题要是改为且从此开始每隔一分钟吃n个Y就难了(n!=1)
//int main() 
//{
//	int x = 10;
//	int y = 90;
//	int i = 0;
//	for (i = 0; i<120;i++)//i表示30s
//	{
//		if (i % 2 == 1)//判断是否为奇数 是的话 y就被x吃
//		{
//			y = y - x;
//		}
//		if (i % 4 == 0)//每俩分钟y的数量翻倍
//		{
//			y = 2 * y;
//		}
//		if (i % 6 == 0)//每三分钟x的数量翻倍
//		{
//			x = 2 * x;
//		}
//	}
//	printf("x = %d y = %d ",x,y);//x = 10485760 y = -979369984 //也就是说x = 10 y = 89时 y在60分钟结果为0
//	//若x = 10 y = 90 x = 10485760 y = 94371840
//	return 0;
//}

//第二题：古堡算式 福尔摩斯到某古堡探险，看到门上写着一个奇怪的算式：ABCDE* ? = EDCBA。
//他对华生说：“ABCDE应该代表不同的数字，问号也代表某个数字！” 华生：“我猜也是！”，于是，两人沉默了好久，还是没有算出合适的结果来。
//请你利用计算机的优势，找到破解的答案，把ABCDE所代表的数字写出来。
//暴力杯 雀氏暴力 没看到ABCDE代表不同的数字这个条件
//int main() 
//{
//	int a = 0;
//	int b = 0;
//	int c = 0;
//	int d = 0;
//	int e = 0;
//	int x = 0;
//	for (int a = 1; a <=9; a++)
//	{
//		for (int b = 0; b<=9; b++)
//		{
//			for (int c = 0; c<=9; c++)
//			{
//				for (int d = 0; d<=9; d++)
//				{
//					for (int e = 0; e<=9; e++)
//					{
//						for (int x = 0; x<=9; x++)
//						{
//							if ( ((a * 10000 + b * 1000 + c * 100 + d * 10 + e) * x) == (e * 10000 + d * 1000 + c * 100 + b * 10 + a))
//							{
//								if (a!=b &&a!=c&&a!=d&&a!=e&&b!=c&&b!=d&&b!=e&&c!=d&&c!=e&&d!=e)
//								{
//									printf("a = %d  b = %d  c = %d d = %d e = %d ?= %d \n", a, b, c, d, e, x);
//									//巨笨的方法 算出结果为a = 2  b = 1  c = 9 d = 7 e = 8 ?= 4
//								}
//							}
//							
//						}
//					}
//				}
//			}
//		}
//	}
//	return 0;
//}
//方法2
//由于这5个数分别是个位十位百位千位 所以可以用取余的方法表示这五个数 注意int型的最大长度是32767
//所以要用10w以上的数 不能用int型
//要细心细心在细心 每一步都要想清楚再打
//int main() 
//{
//	 int a,b,c,d,e ;//范围是 -2147483647~+2147483647
//	 long int i = 0;
//	for (i = 10000; i <= 99999; i++)//注意这个数一定>=10000 <=99999所以起始条件写上i=10000 终止条件<=999999
//	{
//		a = i / 10000;//a = i % 10000;错误 例如a=34000 %10000 = 4000
//		b = (i / 1000) % 10;
//		c = (i / 100) % 10;
//		d = (i / 10) % 10;
//		e = i % 10;
//		int x = 0;
//		for (x = 0; x <= 9; x++)
//		{
//			if ((e * 10000 + d * 1000 + c * 100 + b * 10 + a) == i*x)
//			{
//				if(a != b && a != c && a != d && a != e && b != c && b != d && b != e && c != d && c != e && d != e)
//				{
//					printf("%d %d", i,x);
//				}	
//			}
//		}
//	}
//}

//第三题：比酒量
//题目描述
//有一群海盗（不多于20人），在船上比拼酒量。过程如下：打开一瓶酒，所有在场的人平分喝下，有几个人倒下了。
//再打开一瓶酒平分，又有倒下的，再次重复----直到开了第4瓶酒，坐着的已经所剩无几，海盗船长也在其中。
//当第4瓶酒平分喝下后，大家都倒下了。等船长醒来，发现海盗船搁浅了。他在航海日志中写到：“…昨天，我正好喝了一瓶…奉劝大家，开船不喝酒，喝酒别开船…”
//请你根据这些信息，推断开始有多少人，每一轮喝下来还剩多少人。如果有多个可能的答案，请列出所有答案，每个答案占一行。格式是：人数，人数，…
//例如，有一种可能是：20, 5, 4, 2, 0
//题目分析:首先这群海盗最多有20人 每次最少要喝倒一个人 所以四轮最少有四个人 船长喝4轮加起来的酒刚好是一瓶(注意由于1瓶酒要均分 所以比较类型肯定要浮点型)  四轮全都喝完了
//int main() 
//{
//	int a, b, c, d;//分别代表海盗人数 第一轮喝完后的海盗人数 第二轮喝完后的海盗人数 第三轮喝完后的海盗人数 第四轮的喝完后为0不用管
//	for (a = 20; a >= 4; a--)
//	{
//		for (b = a - 1; b >= 3; b--) 
//		{
//			for (c = b - 1; c >=2; c--) 
//			{
//				for (d = c - 1; d >=1; d--)
//				{
//						if ((float)(1.0/a+1.0/b+1.0/c+1.0/d) == 1.0)
//						{
//							printf("%d %d %d %d，0\n", a, b, c, d);
//						}
//				}
//			}
//		}
//	}
//	return 0;
//}
// 
//第四题：奇怪的比赛
//题目描述
//某电视台举办了低碳生活大奖赛。题目的计分规则相当奇怪：每位选手需要回答10个问题（其编号为1到10）,
//越后面越有难度。答对的，当前分数翻倍；答错了则扣掉与题号相同的分数（选手必须回答问题，不回答按错误处理）。
//每位选手的起步分都是10分，某获胜选手最终得分刚好是100分，如果不让你看比赛过程，你能推断出他（她）哪个题目答对了，哪个题目答错了吗？
//如果把答对的记为1，答错的记为0，则10个题目的回答情况可用仅含1和0的串来表示，如0010110011就是可能的情况。
//你的任务是算出所有可能情况，每个答案占一行。
//一般来说递推(一步步向前推进得出结果)的效率是高于(递归的) 因为递归一次就要调用一次函数就要压栈一次
//方法一(笨方法)  先定义一个数组 然后用这个数组来存放每次判断的值0,1 采用穷举法 把所有结果列出 然后进行判断
//int main() 
//{
//	int arr[11] = { 0 };//要么初始到11 要不直接不写 因为写的下标是1开始的到10结束 实际上是0开始10结束 
//	for (arr[1] = 0; arr[1] <= 1; arr[1]++) 
//	{
//		for (arr[2] = 0; arr[2] <= 1; arr[2]++)
//		{
//			for (arr[3] = 0; arr[3] <= 1; arr[3]++)
//			{
//				for (arr[4] = 0; arr[4] <= 1; arr[4]++)
//				{
//					for (arr[5] = 0; arr[5] <= 1; arr[5]++)
//					{
//						for (arr[6] = 0; arr[6] <= 1; arr[6]++)
//						{
//							for (arr[7] = 0; arr[7] <= 1; arr[7]++)
//							{
//								for (arr[8] = 0; arr[8] <= 1; arr[8]++)
//								{
//									for (arr[9] = 0; arr[9] <= 1; arr[9]++)
//									{
//										for (arr[10] = 0; arr[10] <= 1; arr[10]++)
//										{
//											int i =1;
//											int grade = 10;//总共有2^10个结果 每次算结果时先初始化grade的值 必须写在这 否则grade不会被再次初始化为10
//											for (i = 1; i<=10;i++)
//											{
//												if (arr[i] == 1)
//												{
//													grade *= 2;
//												}
//												else 
//												{
//													grade -= i;
//												}
//											}
//											if (grade == 100)
//											{
//												for (i = 1; i <= 10; i++) 
//												{
//													printf("%d", arr[i]);
//												}
//												printf("\n");
//											}
//										}
//									}
//								}
//							}
//						}
//					}
//				}
//			}
//		}
//	}
//}
 
//递归实现
//int i = 0;
//int arr[11] = { 0 };
////用递归最好把能定义在外面的变量都在递归外面定义
//void competition(int grade , int time) 
//{
//	//int arr[11] = { 0 };//若这条语句写在这里直接报栈溢出 因为最后有2^10个结果 每递归一次都会定义一个int arr[]的数组 而这个数组的长度是44个字节
//	if (time > 11) 
//	{
//		return;//没满足条件直接结束
//	}
//	if (grade == 100 && time == 11)
//	{
//
//		for (i = 1; i <= 10; i++)
//		{
//			printf("%d", arr[i]);
//		}
//		printf("\n");
//		return ;
//	}
//	arr[time] = 1;//注意这里不能写在if里面 因为不需要条件 必定要执行递归的
//	competition(grade *2, time + 1);//下一次递归的条件写成grade *= grade了 实际上递归的下一次是grade = 你传入的参数 所以你传grade *= grade他就懵了
//
//	arr[time] = 0;
//	competition(grade - time, time + 1);
//}
////用递归方式实现 开始传入初始分值和循环的次数
//int main() 
//{
//	competition(10, 1);
//	return 0;
//}

//第五题：方阵转置
//题目描述
//对一个方阵转置，就是把原来的行号变列号，原来的列号变行号。例如，如下方阵：
//x矩阵
//1 2 3 4
//5 6 7 8
//9 10 11 12
//13 14 15 16
//转置后变为：
//1 5 9 13
//2 6 10 14
//3 7 11 15
//4 8 12 16
//但如果是对该方阵顺时针旋转（不是转置），却是如下结果：
// y矩阵
//13 9 5 1   
//14 10 6 2
//15 11 7 3
//16 12 8 4
//下面代码实现的功能就是要把一个方阵顺时针旋转，请推测划线处的代码。
//题目分析：旋转后的坐标每个数的横坐标不变,纵坐标变化 表示为 数字1的坐标变化是 y[0][3] = x[0][0]  数字2的坐标变化是 y[0][2] = x[0][1] 
//数字3的坐标变化是y[0][1] = x[0][2] 也就是原坐标加新坐标的和是列数-1
//[x][y] = [x][rank-1-y]二维数组的坐标是这样表示的
//二维数组实际上还是一维数组 例第二行第二列的坐标用一维数组表示:行坐标乘上列数加上纵坐标 x[2][2] = x[2*4+2]
//[x][rank-1-y]表示为一维数组 = [x*rank +rank-1-y]
//那么y[  ] = x[i] 填空 首先要反向转二维数组 x[i/4][i%4] 然后把x，y分别带入[x*rank +rank-1-y]得到 [(i/4)*rank + rank -1 -i%4]
//#include<stdio.h>
//void rotate(int* x, int rank)
//{
//	//这里是指构造和原矩阵相同大小的数组 
//	int* y = (int*)malloc(rank * rank * sizeof(int));  // 填空 原填空是int *y=(int*)malloc(___________________); 矩阵16个int大小 这里填16*sizeof(int)也行
//	int i = 0;
//	for (i = 0; i < rank * rank; i++)
//	{
//		y[(i % 4) * 4 + 3 - i / 4] = x[i];  // 填空 原填空是y[    ] = x[i];
//	}
//	for (i = 0; i < rank * rank; i++)
//	{
//		x[i] = y[i];
//	}
//	free(y);
//}
//
//int main(int argc, char* argv[])
//{
//	int x[4][4] = { {1,2,3,4},{5,6,7,8},{9,10,11,12},{13,14,15,16} };
//	int rank = 4;
//	rotate(&x[0][0], rank);
//	for (int i = 0; i < rank; i++)
//	{
//		for (int j = 0; j < rank; j++)
//		{
//			printf("%4d", x[i][j]);
//		}
//		printf("\n");
//	}
//	return 0;
//}
//

//第六题：大数乘法
//题目描述
//对于32位字长的机器，大约超过20亿，用int类型就无法表示了，我们可以选择_int64类型，但无论怎样扩展，固定的整数类型总是有表达的极限！
// 如果对超级大整数进行精确运算呢 ? 一个简单的办法是：仅仅使用现有类型，但是把大整数的运算化解为若干小整数的运算，即所谓“分块法”。
// 下图表示了分块乘法的原理。
//可以把大数分成多段（此处为2段）小数，然后用小数的多次运算组合表示一个大数。
//可以根据int的承载能力规定小块的大小，比如要把int分成2段，则小块可取10000为上限值。注意，小块在进行纵向累加后，需要进行进位校正。
//以下代码示意了分块乘法的原理（乘数、被乘数都分为2段），请分析代码逻辑，并推测划线处的代码。
//这题说实话 看不懂但是仿照着其他行可以写出正确代码 不知道(出题人)在想啥
void bigmul(int x, int y, int r[])//87654321, 12345678, x
{
	int base = 10000;
	int x2 = x / base;//87654321/10000 = 8765... 4321
	int x1 = x % base;//4321
	int y2 = y / base;//1234
	int y1 = y % base;//5678
	int n1 = x1 * y1;//4321*1234
	int n2 = x1 * y2;//4321*5678
	int n3 = x2 * y1;//8765*1234
	int n4 = x2 * y2;//8765*5678
	r[3] = n1 % base;
	r[2] = n1 / base + n2 % base + n3 % base;//注意这里的r[2]的图中是r3 r3上面有m1 m2 m3 
	r[1] = n2 / base + n3 % base + n4 % base; //r[1] = ____________________;  //填空 这里对应的图中的r2 r2上面有m2 m3 m4 仿照上一行填
	r[0] = n4 / base;
	r[1] += r[2] / base; //r[1] += ____________________;  //同理仿照最后俩行 找出答案
	r[2] = r[2] % base;
	r[0] += r[1] / base;
	r[1] = r[1] % base;
}

int main(int argc, char* argv[])
{
	int x[] = { 0,0,0,0 };
	bigmul(87654321, 12345678, x);//计算这俩个数相乘
	printf("%d%d%d%d\n", x[0], x[1], x[2], x[3]);
	return 0;
}
